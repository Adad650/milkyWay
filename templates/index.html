<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <title>Echo - A Web Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }
        html {
            height: 100%;
        }
        #gameCanvas {
            background-color: #000;
            touch-action: none;
        }
        #ui {
            margin-top: 10px;
            text-align: center;
            position: absolute;
            bottom: 20px;
            width: 100%;
            pointer-events: none;
        }
        #message {
            margin-top: 10px;
            color: #ff3333;
            height: 24px;
            font-size: 24px;
            text-shadow: 0 0 5px #000;
        }
        #cooldown-bar {
            width: 300px;
            height: 15px;
            background-color: #333;
            margin: 10px auto;
            border: 2px solid white;
            position: relative;
            display: none;
        }
        #cooldown-fill {
            height: 100%;
            width: 0%;
            background-color: #0099ff;
            transition: width 0.1s linear;
        }
        #cooldown-text {
            position: absolute;
            top: -25px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-size: 18px;
        }
        #level-display {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
            color: white;
            text-shadow: 0 0 5px #000;
        }
        .fullscreen-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            max-width: 80%;
        }
        .fullscreen-message h1 {
            color: #00ff00;
            font-size: 48px;
            margin: 0 0 20px 0;
        }
        .fullscreen-message p {
            font-size: 24px;
            margin: 10px 0;
        }
        #touch-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 0 30px;
            pointer-events: auto;
            z-index: 5;
        }
        .dpad {
            display: grid;
            grid-template-columns: repeat(3, 64px);
            grid-template-rows: repeat(3, 64px);
            gap: 8px;
            justify-items: center;
            align-items: center;
        }
        .touch-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.4);
            background-color: rgba(255,255,255,0.15);
            color: white;
            font-size: 20px;
            font-weight: 600;
            touch-action: none;
        }
        .touch-btn.action {
            width: 90px;
            height: 90px;
            border-radius: 45px;
            font-size: 18px;
            background-color: rgba(0, 162, 255, 0.25);
        }
        .touch-btn.active {
            background-color: rgba(255,255,255,0.3);
        }
        .dpad .touch-btn {
            border-radius: 20px;
        }
        .dpad .touch-btn.blank {
            opacity: 0;
            pointer-events: none;
        }
        @media (max-width: 768px) {
            body {
                padding-bottom: 160px;
            }
            #gameCanvas {
                width: 100vw;
                height: auto;
                max-width: 100vw;
            }
            #touch-controls {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="level-display">Level: <span id="level">1</span></div>
    <div id="ui">
        <div id="cooldown-bar">
            <div id="cooldown-fill"></div>
            <div id="cooldown-text">Echo Cooldown</div>
        </div>
        <div id="message"></div>
    </div>
    <div id="touch-controls">
        <div class="dpad">
            <button class="touch-btn blank"></button>
            <button class="touch-btn" id="btn-up">▲</button>
            <button class="touch-btn blank"></button>
            <button class="touch-btn" id="btn-left">◀</button>
            <button class="touch-btn blank"></button>
            <button class="touch-btn" id="btn-right">▶</button>
            <button class="touch-btn blank"></button>
            <button class="touch-btn" id="btn-down">▼</button>
            <button class="touch-btn blank"></button>
        </div>
        <button class="touch-btn action" id="btn-shift">SHIFT</button>
        <button class="touch-btn action" id="btn-echo">ECHO</button>
    </div>

    <script>
        // Game constants
        const CELL_SIZE = 40;
        const MAZE_WIDTH = 31;
        const MAZE_HEIGHT = 21;
        const CANVAS_WIDTH = MAZE_WIDTH * CELL_SIZE;
        const CANVAS_HEIGHT = MAZE_HEIGHT * CELL_SIZE;

        // Colors
        const COLORS = {
            BLACK: '#000000',
            WHITE: '#FFFFFF',
            WALL: '#000050',
            EXIT: '#00FF00',
            PLAYER: '#0066FF',
            ECHO: 'rgba(0, 200, 255, 0.7)',
            DARKNESS: 'rgba(0, 0, 0, 0.9)',
            DASH: '#78ffb4',
            SHIELD: '#fff28c',
            HAZARD: '#ff5a78'
        };

        // Game assets
        let playerImage = new Image();
        playerImage.src = 'https://hc-cdn.hel1.your-objectstorage.com/s/v3/596845749eb07a7f4f90d02f10aa664dd5102874_player.png';
        
        const TUTORIAL_LINES = [
            'Tutorial Level!',
            'Move with W A S D or the Arrow Keys.',
            'Hold Shift to sprint when you need speed.',
            'Click or tap to blast your echo.',
            'Reach the green exit to move on.'
        ];
        const STORY_FRAGMENTS = [
            'Dispatch Log 17A: Prototype Echo Bot 6 went missing in this wing.',
            'Memo: The maze keeps shifting so nobody reaches the broadcast tower.',
            'Journal: I left resonance shards around—collect them and remember.',
            'Studio Note: The boss wanted cameras, but we promised to find survivors.',
            'Final Reminder: Reach the broadcast core and tell the city the truth.'
        ];
        const STORY_DURATION = 6000;
        const BOOST_DURATION = 6000;
        const STATUS_MESSAGE_DURATION = 2800;
        const SPEED_BOOST_MULTIPLIER = 1.35;
        const MAX_SHIELD_CHARGES = 2;
        const COMBO_WINDOW = 2500;
        let tutorialLevelActive = false;
        let tutorialLines = [];
        let storyIndex = 0;
        let storyPopup = '';
        let storyPopupTime = 0;

        // Game state
        let state = 'cutscene1'; // Start with first cutscene
        let level = 1;
        let lastEchoTime = 0;
        let baseEchoCooldown = 2000;
        let echoCooldown = baseEchoCooldown; // Start with 2 second cooldown
        let echoBoostTimer = 0;
        let speedBoostTimer = 0;
        let cooldownMessage = '';
        let cooldownTimer = 0;
        let gameComplete = false;
        let collectibles = [];
        let resonatorsFound = 0;
        let resonatorsTotal = 0;
        let shieldCharges = 0;
        let statusMessage = '';
        let statusMessageTime = 0;
        let staticFields = [];
        let hazardGraceTimer = 0;
        let echoComboCount = 0;
        let lastComboTime = 0;
        let comboBoostTimer = 0;

        let audioCtx = null;

        function ensureAudioContext() {
            if (!audioCtx) {
                const Ctx = window.AudioContext || window.webkitAudioContext;
                if (Ctx) {
                    audioCtx = new Ctx();
                }
            }
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            return audioCtx;
        }

        function playTone(freq, duration = 0.2, volume = 0.2) {
            const ctxAudio = ensureAudioContext();
            if (!ctxAudio) return;
            const oscillator = ctxAudio.createOscillator();
            const gainNode = ctxAudio.createGain();
            oscillator.type = 'sine';
            oscillator.frequency.value = freq;
            gainNode.gain.value = volume;
            oscillator.connect(gainNode);
            gainNode.connect(ctxAudio.destination);

            const now = ctxAudio.currentTime;
            oscillator.start(now);
            gainNode.gain.setValueAtTime(volume, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
            oscillator.stop(now + duration);
        }

        const playEchoSound = () => playTone(660, 0.15, 0.35);
        const playPickupSound = () => playTone(900, 0.12, 0.3);
        const playLoreSound = () => playTone(520, 0.25, 0.25);
        const playExitSound = () => playTone(420, 0.3, 0.35);
        const playShieldSound = () => playTone(220, 0.2, 0.45);
        const playDashSound = () => playTone(1040, 0.16, 0.35);

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const touchControls = document.getElementById('touch-controls');
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (!isTouchDevice && touchControls) {
            touchControls.style.display = 'none';
        }
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Game objects
        const player = {
            x: CELL_SIZE / 2,
            y: CELL_SIZE / 2,
            hitRadius: 12,
            drawRadius: 18,
            speed: 2
        };

        let maze = [];
        let walls = [];
        let exit = { x: 0, y: 0 };
        let echoes = [];
        let levelComplete = false;

        // Generate maze using recursive backtracking (same as Pygame version)
        function generateMaze(width, height) {
            const maze = Array(height).fill().map(() => Array(width).fill(1));
            const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]];
            
            function carve(x, y) {
                maze[y][x] = 0;
                
                // Shuffle directions
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }
                
                for (const [dx, dy] of directions) {
                    const nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && maze[ny][nx] === 1) {
                        maze[y + dy/2][x + dx/2] = 0;
                        carve(nx, ny);
                    }
                }
            }
            
            carve(0, 0);
            maze[0][0] = 0;
            maze[height - 1][width - 1] = 0;
            return maze;
        }

        function setupLevel() {
            tutorialLevelActive = (level === 1);
            tutorialLines = tutorialLevelActive ? [...TUTORIAL_LINES] : [];
            
            // Generate new maze
            maze = generateMaze(MAZE_WIDTH, MAZE_HEIGHT);
            
            // Reset player position
            player.x = CELL_SIZE / 2;
            player.y = CELL_SIZE / 2;
            
            // Set exit position
            exit.x = (MAZE_WIDTH - 1) * CELL_SIZE + CELL_SIZE/2;
            exit.y = (MAZE_HEIGHT - 1) * CELL_SIZE + CELL_SIZE/2;
            
            // Reset walls array
            walls = [];
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 1) {
                        walls.push({
                            x: x * CELL_SIZE,
                            y: y * CELL_SIZE,
                            width: CELL_SIZE,
                            height: CELL_SIZE
                        });
                    }
                }
            }
            
            // Clear echoes and reset level state
            echoes = [];
            levelComplete = false;
            collectibles = spawnCollectibles();
            resonatorsFound = 0;
            resonatorsTotal = collectibles.filter(item => item.type === 'resonator').length;
            storyPopup = '';
            storyPopupTime = 0;
            echoBoostTimer = 0;
            speedBoostTimer = 0;
            echoCooldown = baseEchoCooldown;
            shieldCharges = 0;
            statusMessage = '';
            statusMessageTime = 0;
            staticFields = tutorialLevelActive ? [] : spawnStaticFields();
            hazardGraceTimer = 0;
            echoComboCount = 0;
            comboBoostTimer = 0;
            lastComboTime = 0;
            
            // Update level display
            document.getElementById('level').textContent = tutorialLevelActive ? 'Tutorial' : level;
        }

        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        function spawnCollectibles() {
            const spots = [];
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 0 && !(x === 0 && y === 0) && !(x === MAZE_WIDTH - 1 && y === MAZE_HEIGHT - 1)) {
                        spots.push({ x, y });
                    }
                }
            }
            if (spots.length === 0) return [];
            shuffleArray(spots);
            const items = [];

            const grabCell = () => spots.length ? spots.pop() : { x: Math.floor(Math.random() * MAZE_WIDTH), y: Math.floor(Math.random() * MAZE_HEIGHT) };
            const centerFromCell = (cell) => ({
                x: cell.x * CELL_SIZE + CELL_SIZE / 2,
                y: cell.y * CELL_SIZE + CELL_SIZE / 2
            });

            if (storyIndex < STORY_FRAGMENTS.length) {
                const cell = grabCell();
                const center = centerFromCell(cell);
                items.push({
                    type: 'story',
                    x: center.x,
                    y: center.y,
                    radius: 12,
                    text: STORY_FRAGMENTS[storyIndex],
                    pulseOffset: Math.random() * 400
                });
            }

            const extra = Math.min(1 + Math.floor(level / 2), 4);
            for (let i = 0; i < extra; i++) {
                if (!spots.length) break;
                const cell = grabCell();
                if (!cell) break;
                const center = centerFromCell(cell);
                items.push({
                    type: 'resonator',
                    x: center.x,
                    y: center.y,
                    radius: 8,
                    pulseOffset: Math.random() * 400
                });
            }
            const dashCount = 1 + Math.floor(level / 3);
            for (let i = 0; i < dashCount; i++) {
                if (!spots.length) break;
                const cell = grabCell();
                if (!cell) break;
                const center = centerFromCell(cell);
                items.push({
                    type: 'dash',
                    x: center.x,
                    y: center.y,
                    radius: 10,
                    pulseOffset: Math.random() * 500
                });
            }
            if (level >= 2) {
                const shieldCount = level < 5 ? 1 : 2;
                for (let i = 0; i < shieldCount; i++) {
                    if (!spots.length) break;
                    const cell = grabCell();
                    if (!cell) break;
                    const center = centerFromCell(cell);
                    items.push({
                        type: 'shield',
                        x: center.x,
                        y: center.y,
                        radius: 10,
                        pulseOffset: Math.random() * 600
                    });
                }
            }
            return items;
        }

        function getOpenCells() {
            const cells = [];
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 0 && !(x === 0 && y === 0)) {
                        cells.push({ x, y });
                    }
                }
            }
            return cells;
        }

        function spawnStaticFields() {
            const cells = getOpenCells();
            const hazards = [];
            const count = Math.min(3 + level, 8);
            for (let i = 0; i < count && cells.length; i++) {
                const idx = Math.floor(Math.random() * cells.length);
                const cell = cells.splice(idx, 1)[0];
                hazards.push({
                    x: cell.x * CELL_SIZE + CELL_SIZE / 2,
                    y: cell.y * CELL_SIZE + CELL_SIZE / 2,
                    size: CELL_SIZE - 18,
                    pulseOffset: Math.random() * 300
                });
            }
            return hazards;
        }

        // Check collision between two rectangles
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // Handle player movement
        const keys = new Set();
        const keyMap = {
            'arrowup': 'up',
            'w': 'up',
            'arrowdown': 'down',
            's': 'down',
            'arrowleft': 'left',
            'a': 'left',
            'arrowright': 'right',
            'd': 'right',
            'shift': 'sprint'
        };

        // Track active movement directions
        const activeDirections = {
            up: false,
            down: false,
            left: false,
            right: false,
            sprint: false
        };

        // Handle keydown
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys.add(key);
            
            // Update active directions
            const direction = keyMap[key];
            if (direction) {
                activeDirections[direction] = true;
            }
            
            // Prevent default for movement and space keys
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'w', 'a', 's', 'd', 'shift'].includes(key)) {
                e.preventDefault();
            }
        });
        
        // Handle keyup
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            keys.delete(key);
            
            // Update active directions
            const direction = keyMap[key];
            if (direction) {
                activeDirections[direction] = false;
            }
        });
        
        // Handle window blur (reset all keys when window loses focus)
        window.addEventListener('blur', () => {
            keys.clear();
            Object.keys(activeDirections).forEach(key => {
                activeDirections[key] = false;
            });
        });

        function movePlayer() {
            if (levelComplete) return;
            updateBoostTimer();
            const now = Date.now();
            if (speedBoostTimer && now > speedBoostTimer) {
                speedBoostTimer = 0;
            }
            
            const prevX = player.x;
            const prevY = player.y;
            
            // Calculate movement vector
            let moveX = 0;
            let moveY = 0;
            
            // Base speed (normal walking speed)
            const baseSpeed = 2;
            const sprintMultiplier = 2; // Double speed when sprinting
            
            // Calculate movement based on active directions
            if (activeDirections.up) moveY -= 1;
            if (activeDirections.down) moveY += 1;
            if (activeDirections.left) moveX -= 1;
            if (activeDirections.right) moveX += 1;
            
            // Normalize diagonal movement (so moving diagonally isn't faster)
            if (moveX !== 0 && moveY !== 0) {
                const invSqrt2 = 0.7071; // 1/sqrt(2)
                moveX *= invSqrt2;
                moveY *= invSqrt2;
            }
            
            // Apply sprint if shift is held
            let speedMultiplier = activeDirections.sprint ? sprintMultiplier : 1;
            if (speedBoostTimer && speedBoostTimer > now) {
                speedMultiplier *= SPEED_BOOST_MULTIPLIER;
            }
            const speed = baseSpeed * speedMultiplier;
            
            // Update player position
            player.x += moveX * speed;
            player.y += moveY * speed;
            
            // Create player rectangle for collision detection
            const playerRect = {
                x: player.x - player.hitRadius,
                y: player.y - player.hitRadius,
                width: player.hitRadius * 2,
                height: player.hitRadius * 2
            };

            handleCollectibles();
            
            // Wall collision
            for (const wall of walls) {
                if (checkCollision(playerRect, wall)) {
                    player.x = prevX;
                    player.y = prevY;
                    break;
                }
            }
            
            // Keep player in bounds
            player.x = Math.max(player.hitRadius, Math.min(player.x, CANVAS_WIDTH - player.hitRadius));
            player.y = Math.max(player.hitRadius, Math.min(player.y, CANVAS_HEIGHT - player.hitRadius));
            checkStaticFields();
            
            // Check if reached exit
            const distToExit = Math.hypot(player.x - exit.x, player.y - exit.y);
            if (distToExit < CELL_SIZE && !levelComplete) {
                levelComplete = true;
                level++;
                baseEchoCooldown = Math.max(500, 2000 - level * 100);
                echoCooldown = baseEchoCooldown;
                echoBoostTimer = 0;
                playExitSound();
                
                // Show level complete message
                showMessage('Level Complete!', 1500, () => {
                    setupLevel();
                });
            }
        }

        function updateBoostTimer(now = Date.now()) {
            if (echoBoostTimer && now > echoBoostTimer) {
                echoBoostTimer = 0;
            }
            if (comboBoostTimer && now > comboBoostTimer) {
                comboBoostTimer = 0;
            }
            if (echoComboCount && now - lastComboTime > COMBO_WINDOW) {
                echoComboCount = 0;
            }
            let cooldown = baseEchoCooldown;
            if (echoBoostTimer) {
                cooldown = Math.min(cooldown, Math.max(400, baseEchoCooldown * 0.45));
            }
            if (comboBoostTimer) {
                cooldown = Math.min(cooldown, Math.max(300, baseEchoCooldown * 0.35));
            }
            echoCooldown = Math.max(250, cooldown);
        }

        function handleCollectibles() {
            if (!collectibles.length) return;
            const now = Date.now();
            const remaining = [];
            for (const item of collectibles) {
                const dist = Math.hypot(player.x - item.x, player.y - item.y);
                if (dist < item.radius + player.hitRadius) {
                    if (item.type === 'resonator') {
                        resonatorsFound = Math.min(resonatorsTotal, resonatorsFound + 1);
                        echoBoostTimer = now + BOOST_DURATION;
                        showMessage('Echo boost active!', 900);
                        playPickupSound();
                    } else if (item.type === 'story') {
                        storyPopup = item.text;
                        storyPopupTime = now;
                        if (storyIndex < STORY_FRAGMENTS.length) {
                            storyIndex++;
                        }
                        playLoreSound();
                    } else if (item.type === 'dash') {
                        speedBoostTimer = now + BOOST_DURATION;
                        statusMessage = 'Thrusters engaged! You are faster.';
                        statusMessageTime = now;
                        showMessage('Thrusters active!', 900);
                        playDashSound();
                    } else if (item.type === 'shield') {
                        shieldCharges = Math.min(MAX_SHIELD_CHARGES, shieldCharges + 1);
                        statusMessage = `Shield stored (${shieldCharges}/${MAX_SHIELD_CHARGES})`;
                        statusMessageTime = now;
                        playShieldSound();
                    }
                    updateBoostTimer(now);
                } else {
                    remaining.push(item);
                }
            }
            collectibles = remaining;
        }

        function checkStaticFields() {
            if (!staticFields.length) return;
            const now = Date.now();
            if (hazardGraceTimer && now < hazardGraceTimer) return;
            const playerRect = {
                x: player.x - player.hitRadius,
                y: player.y - player.hitRadius,
                width: player.hitRadius * 2,
                height: player.hitRadius * 2
            };
            for (const field of staticFields) {
                const size = field.size;
                const fieldRect = {
                    x: field.x - size / 2,
                    y: field.y - size / 2,
                    width: size,
                    height: size
                };
                if (checkCollision(playerRect, fieldRect)) {
                    hazardGraceTimer = now + 1200;
                    if (shieldCharges > 0) {
                        shieldCharges--;
                        statusMessage = 'Shield absorbed static shock!';
                        statusMessageTime = now;
                    } else {
                        player.x = CELL_SIZE / 2;
                        player.y = CELL_SIZE / 2;
                        statusMessage = 'Static field zapped you!';
                        statusMessageTime = now;
                    }
                    break;
                }
            }
        }

        // Show a temporary message
        function showMessage(message, duration = 1000, callback = null) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = message;
            messageEl.style.display = 'block';
            
            setTimeout(() => {
                messageEl.textContent = '';
                messageEl.style.display = 'none';
                if (callback) callback();
            }, duration);
        }

        function requestEcho(e) {
            if (e) e.preventDefault();
            if (state !== 'game') return;
            handleEcho();
        }

        // Handle mouse/touch for echoes
        function handleEchoCombo(now) {
            if (now - lastComboTime <= COMBO_WINDOW) {
                echoComboCount += 1;
            } else {
                echoComboCount = 1;
            }
            lastComboTime = now;
            if (echoComboCount >= 3) {
                comboBoostTimer = now + 5000;
                statusMessage = `Echo combo x${echoComboCount}!`;
                statusMessageTime = now;
            }
            updateBoostTimer(now);
        }

        function handleEcho() {
            const currentTime = Date.now();
            if (currentTime - lastEchoTime >= echoCooldown) {
                echoes.push({
                    x: player.x,
                    y: player.y,
                    radius: 5,
                    maxRadius: 300,
                    alpha: 1,
                    speed: 8
                });
                
                lastEchoTime = currentTime;
                playEchoSound();
                handleEchoCombo(currentTime);
                
                // Show cooldown UI
                const cooldownBar = document.getElementById('cooldown-bar');
                const cooldownFill = document.getElementById('cooldown-fill');
                
                cooldownBar.style.display = 'block';
                cooldownFill.style.transition = `width ${echoCooldown}ms linear`;
                
                // Trigger the animation
                setTimeout(() => {
                    cooldownFill.style.width = '100%';
                }, 10);
                
                setTimeout(() => {
                    cooldownBar.style.display = 'none';
                    cooldownFill.style.width = '0%';
                }, echoCooldown);
                
                // Play echo sound (you'll need to add a sound file for this to work)
                // playSound('echo.mp3');
            } else {
                cooldownMessage = 'Echo On Cooldown';
                showMessage(cooldownMessage, 1000);
            }
        }
        
        function bindDirectionButton(id, direction) {
            const btn = document.getElementById(id);
            if (!btn) return;
            const press = (e) => {
                e.preventDefault();
                activeDirections[direction] = true;
                btn.classList.add('active');
            };
            const release = (e) => {
                e.preventDefault();
                activeDirections[direction] = false;
                btn.classList.remove('active');
            };
            ['touchstart', 'mousedown'].forEach(evt => btn.addEventListener(evt, press));
            ['touchend', 'touchcancel', 'mouseup', 'mouseleave'].forEach(evt => btn.addEventListener(evt, release));
        }

        function bindActionButton(id, handler) {
            const btn = document.getElementById(id);
            if (!btn) return;
            const press = (e) => {
                e.preventDefault();
                handler(true);
                btn.classList.add('active');
            };
            const release = (e) => {
                e.preventDefault();
                handler(false);
                btn.classList.remove('active');
            };
            ['touchstart', 'mousedown'].forEach(evt => btn.addEventListener(evt, press));
            ['touchend', 'touchcancel', 'mouseup', 'mouseleave'].forEach(evt => btn.addEventListener(evt, release));
        }

        // Set up event listeners for echo
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                requestEcho(e);
            }
        });
        canvas.addEventListener('click', (e) => {
            if (e.button === 0) {
                requestEcho(e);
            }
        });
        canvas.addEventListener('touchstart', requestEcho, { passive: false });
        if (isTouchDevice) {
            bindDirectionButton('btn-up', 'up');
            bindDirectionButton('btn-down', 'down');
            bindDirectionButton('btn-left', 'left');
            bindDirectionButton('btn-right', 'right');
            bindActionButton('btn-echo', (pressed) => {
                if (pressed) requestEcho();
            });
            bindActionButton('btn-shift', (pressed) => {
                activeDirections.sprint = pressed;
            });
        }

        // Update echoes
        function updateEchoes() {
            for (let i = echoes.length - 1; i >= 0; i--) {
                const echo = echoes[i];
                echo.radius += echo.speed;
                echo.alpha = 1 - (echo.radius / echo.maxRadius);
                
                if (echo.alpha <= 0) {
                    echoes.splice(i, 1);
                }
            }
        }

        // Draw functions
        function drawMaze() {
            // Draw walls
            ctx.fillStyle = COLORS.WALL;
            for (const wall of walls) {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            }
            
            // Draw exit
            ctx.fillStyle = COLORS.EXIT;
            ctx.fillRect(
                (MAZE_WIDTH - 1) * CELL_SIZE, 
                (MAZE_HEIGHT - 1) * CELL_SIZE, 
                CELL_SIZE, 
                CELL_SIZE
            );
        }

        function drawPlayer() {
            if (shieldCharges) {
                ctx.save();
                ctx.strokeStyle = COLORS.SHIELD;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.drawRadius + 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            // Draw player sprite
            if (playerImage.complete) {
                ctx.save();
                ctx.translate(player.x, player.y);
                // Scale down the image (assuming original is larger than we want)
                ctx.drawImage(playerImage, -player.drawRadius, -player.drawRadius, player.drawRadius * 2, player.drawRadius * 2);
                ctx.restore();
            } else {
                // Fallback circle if image isn't loaded
                ctx.fillStyle = COLORS.PLAYER;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.drawRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawTutorialOverlay() {
            if (!tutorialLevelActive || tutorialLines.length === 0) {
                return;
            }
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            const panelHeight = 160;
            ctx.fillRect(0, 50, CANVAS_WIDTH, panelHeight);
            ctx.fillStyle = COLORS.WHITE;
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            tutorialLines.forEach((line, index) => {
                ctx.fillText(line, CANVAS_WIDTH / 2, 85 + index * 28);
            });
            ctx.restore();
        }

        function drawCollectibles() {
            if (!collectibles.length) return;
            const now = Date.now();
            for (const item of collectibles) {
                const pulse = 2 + Math.sin((now + item.pulseOffset) / 200) * 3;
                if (item.type === 'resonator') {
                    ctx.fillStyle = 'rgba(90, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.radius + pulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else if (item.type === 'story') {
                    ctx.fillStyle = 'rgba(255, 210, 120, 0.95)';
                    ctx.beginPath();
                    ctx.moveTo(item.x, item.y - (item.radius + pulse));
                    ctx.lineTo(item.x + item.radius + pulse, item.y);
                    ctx.lineTo(item.x, item.y + (item.radius + pulse));
                    ctx.lineTo(item.x - item.radius - pulse, item.y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else if (item.type === 'dash') {
                    ctx.strokeStyle = COLORS.DASH;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.radius + pulse, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(item.x - 8, item.y);
                    ctx.lineTo(item.x + 8, item.y);
                    ctx.stroke();
                } else if (item.type === 'shield') {
                    ctx.fillStyle = COLORS.SHIELD;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const px = item.x + (item.radius + pulse) * Math.cos(angle);
                        const py = item.y + (item.radius + pulse) * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        function drawStaticFields() {
            if (!staticFields.length) return;
            const now = Date.now();
            staticFields.forEach(field => {
                const pulse = 2 + Math.sin((now + field.pulseOffset) / 180) * 2;
                const size = field.size + pulse;
                ctx.strokeStyle = COLORS.HAZARD;
                ctx.lineWidth = 2;
                ctx.strokeRect(field.x - size / 2, field.y - size / 2, size, size);
                ctx.fillStyle = COLORS.HAZARD;
                ctx.globalAlpha = 0.4;
                ctx.fillRect(field.x - (field.size / 2), field.y - (field.size / 2), field.size, field.size);
                ctx.globalAlpha = 1;
            });
        }

        function drawHud() {
            ctx.save();
            const now = Date.now();
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            const levelLabel = tutorialLevelActive ? 'Tutorial' : `Level ${level}`;
            ctx.fillText(levelLabel, 12, 26);
            if (resonatorsTotal > 0) {
                ctx.textAlign = 'right';
                ctx.fillStyle = '#5dfbff';
                ctx.fillText(`Echo shards ${resonatorsFound}/${resonatorsTotal}`, CANVAS_WIDTH - 12, 26);
            }
            if (echoBoostTimer) {
                ctx.fillStyle = '#5dfbff';
                const remain = Math.max(0, (echoBoostTimer - now) / 1000);
                ctx.fillText(`Boost ${remain.toFixed(1)}s`, CANVAS_WIDTH - 12, 50);
            }
            if (shieldCharges) {
                ctx.fillStyle = COLORS.SHIELD;
                ctx.fillText(`Shields ${shieldCharges}/${MAX_SHIELD_CHARGES}`, CANVAS_WIDTH - 12, 74);
            }
            if (speedBoostTimer) {
                ctx.fillStyle = COLORS.DASH;
                const remain = Math.max(0, (speedBoostTimer - now) / 1000);
                ctx.fillText(`Thrusters ${remain.toFixed(1)}s`, CANVAS_WIDTH - 12, 98);
            }
            ctx.textAlign = 'left';
            ctx.fillStyle = '#FFFFFF';
            const statusLines = [];
            if (speedBoostTimer && speedBoostTimer > now) {
                statusLines.push('Thrusters engaged.');
            }
            if (shieldCharges) {
                statusLines.push('Shields block the next collision.');
            }
            if (staticFields.length) {
                statusLines.push(`Static fields: ${staticFields.length}`);
            }
            if (echoComboCount && now - lastComboTime <= COMBO_WINDOW) {
                statusLines.push(`Echo combo x${echoComboCount}`);
            }
            statusLines.push(`Story logs ${Math.min(storyIndex, STORY_FRAGMENTS.length)}/${STORY_FRAGMENTS.length}`);
            statusLines.forEach((line, idx) => {
                ctx.fillText(line, 12, 70 + idx * 22);
            });

            const panelX = CANVAS_WIDTH - 340;
            const panelY = CANVAS_HEIGHT - 180;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
            ctx.fillRect(panelX, panelY, 320, 120);
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'left';
            const logLines = [
                `Story logs ${Math.min(storyIndex, STORY_FRAGMENTS.length)}/${STORY_FRAGMENTS.length}`,
                `Exit: ${levelComplete ? 'open' : 'find it'}`,
                `Shields: ${shieldCharges}/${MAX_SHIELD_CHARGES}`,
                `Thrusters: ${speedBoostTimer && speedBoostTimer > now ? 'online' : 'offline'}`
            ];
            logLines.forEach((line, idx) => {
                ctx.fillText(line, panelX + 12, panelY + 24 + idx * 24);
            });
            ctx.restore();
        }

        function drawStoryOverlay() {
            if (!storyPopup || Date.now() - storyPopupTime > STORY_DURATION) return;
            ctx.save();
            const panelHeight = 90;
            const panelY = CANVAS_HEIGHT - panelHeight - 40;
            ctx.fillStyle = 'rgba(10, 10, 20, 0.8)';
            ctx.fillRect(40, panelY, CANVAS_WIDTH - 80, panelHeight);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.strokeRect(40, panelY, CANVAS_WIDTH - 80, panelHeight);
            ctx.fillStyle = '#FFD278';
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            wrapText(ctx, storyPopup, 60, panelY + 30, CANVAS_WIDTH - 120, 24);
            ctx.restore();
        }

        function drawStatusMessage() {
            if (!statusMessage || Date.now() - statusMessageTime > STATUS_MESSAGE_DURATION) return;
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, CANVAS_HEIGHT - 140, CANVAS_WIDTH, 40);
            ctx.fillStyle = COLORS.DASH;
            ctx.font = '22px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(statusMessage, CANVAS_WIDTH / 2, CANVAS_HEIGHT - 112);
            ctx.restore();
        }

        function drawEchoes() {
            // Draw complete darkness first
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Create a clipping region for visible areas
            ctx.save();
            ctx.beginPath();
            
            // Add a small area around the player that's always visible
            const baseGlow = Math.max(player.drawRadius, player.hitRadius + 4);
            ctx.arc(player.x, player.y, baseGlow, 0, Math.PI * 2);
            
            // Add echo circles as visible areas if they exist
            for (const echo of echoes) {
                ctx.moveTo(echo.x + echo.radius, echo.y);
                ctx.arc(echo.x, echo.y, echo.radius, 0, Math.PI * 2);
                
                // Draw echo ring
                ctx.strokeStyle = `rgba(0, 200, 255, ${echo.alpha * 0.7})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Use the path to create a clipping region
            ctx.clip();
            
            // Draw the maze in the visible areas
            drawMaze();
            drawCollectibles();
            drawStaticFields();
            
            // Draw the player on top of the maze but within the visible area
            drawPlayer();
            
            // Restore the context
            ctx.restore();
        }

        // Cutscene 1: Conveyor Belt
        async function cutscene1() {
            const robots = [];
            const beltSpeed = 2;
            const beltY = 400;
            
            // Create robots on a conveyor belt with slight vertical variation
            for (let i = 0; i < 6; i++) {
                robots.push({
                    x: 800 + i * 120,
                    y: beltY + (Math.random() * 20 - 10), // Slight vertical variation
                    width: 40,
                    height: 40,
                    frame: Math.floor(Math.random() * 4), // For animation
                    time: Math.random() * 1000 // For animation timing
                });
            }
            
            const startTime = Date.now();
            const duration = 6000; // 6 seconds
            
            // Fade in
            await fadeIn(800);
            
            // Main cutscene loop
            while (Date.now() - startTime < duration) {
                // Clear
                ctx.fillStyle = '#0A0A0A';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Draw conveyor belt
                ctx.fillStyle = '#505050';
                ctx.fillRect(0, beltY - 10, CANVAS_WIDTH, 60);
                
                // Draw belt lights
                ctx.fillStyle = '#1E1E1E';
                for (let i = 0; i < CANVAS_WIDTH; i += 60) {
                    const offset = (Date.now() / 100) % 60;
                    ctx.beginPath();
                    ctx.arc((i + offset) % CANVAS_WIDTH, beltY + 20, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Update and draw robots with animation
                for (const robot of robots) {
                    robot.x -= beltSpeed;
                    if (robot.x < -robot.width) robot.x = CANVAS_WIDTH;
                    
                    // Update animation frame
                    robot.time += 1000 / 60; // Assuming 60fps
                    robot.frame = Math.floor(robot.time / 200) % 4; // Change frame every 200ms
                    
                    // Save context for rotation
                    ctx.save();
                    
                    // Move to robot position and apply slight rotation based on position
                    const rotation = Math.sin(robot.time * 0.005) * 0.1; // Gentle rocking
                    ctx.translate(robot.x + robot.width/2, robot.y + robot.height/2);
                    ctx.rotate(rotation);
                    
                    if (playerImage.complete) {
                        // Draw robot with current frame
                        const frameSize = 64; // Assuming sprite sheet with 64x64 frames
                        const frameX = (robot.frame % 2) * frameSize;
                        const frameY = Math.floor(robot.frame / 2) * frameSize;
                        
                        // Draw shadow
                        ctx.save();
                        ctx.scale(1, 0.3);
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.beginPath();
                        ctx.ellipse(0, 20, robot.width/2, 5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                        
                        // Draw robot
                        ctx.drawImage(
                            playerImage,
                            frameX, frameY, frameSize, frameSize,
                            -robot.width/2, -robot.height/2, robot.width, robot.height
                        );
                    } else {
                        // Fallback if image isn't loaded
                        ctx.fillStyle = COLORS.PLAYER;
                        ctx.fillRect(-robot.width/2, -robot.height/2, robot.width, robot.height);
                    }
                    
                    ctx.restore();
                }
                
                // Draw dialogue with speech bubbles
                const elapsed = Date.now() - startTime;
                
                // Worker 1's speech
                if (elapsed < 3000) {
                    drawSpeechBubble(
                        "Worker 1: We ran out of cameras!",
                        200, 80, 300, 60, 20
                    );
                } 
                // Worker 2's speech
                else {
                    drawSpeechBubble(
                        "Worker 2: Just give him an extra speaker!",
                        180, 130, 400, 60, 20
                    );
                }
                
                // Draw worker sprites (simplified)
                drawWorker(100, 100, 0);
                drawWorker(100, 180, 1);
                
                await new Promise(r => requestAnimationFrame(r));
            }
            
            // Fade out and move to next state
            await fadeOut(600);
            state = 'cutscene2';
        } 1
        
        // Helper function to draw speech bubbles
        function drawSpeechBubble(text, x, y, width, height, radius) {
            // Bubble tail
            const tailSize = 10;
            
            // Draw bubble
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // Rounded rectangle
            roundRect(ctx, x, y, width, height, radius, true, true);
            
            // Tail
            ctx.beginPath();
            ctx.moveTo(x + 40, y + height);
            ctx.lineTo(x + 20, y + height + tailSize);
            ctx.lineTo(x + 60, y + height);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Text
            ctx.fillStyle = '#000';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            wrapText(ctx, text, x + 20, y + 30, width - 40, 20);
        }
        
        // Helper to draw rounded rectangles
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) ctx.fill();
            if (stroke) ctx.stroke();
        }
        
        // Helper to wrap text
        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let testLine = '';
            let lineCount = 0;
            
            for (let n = 0; n < words.length; n++) {
                testLine = line + words[n] + ' ';
                const metrics = context.measureText(testLine);
                const testWidth = metrics.width;
                
                if (testWidth > maxWidth && n > 0) {
                    context.fillText(line, x, y);
                    line = words[n] + ' ';
                    y += lineHeight;
                    lineCount++;
                } else {
                    line = testLine;
                }
            }
            
            context.fillText(line, x, y);
        }
        
        // Draw worker sprite (simplified)
        function drawWorker(x, y, type) {
            ctx.save();
            ctx.translate(x, y);
            
            // Body
            ctx.fillStyle = type === 0 ? '#4a86e8' : '#e69138';
            ctx.fillRect(-15, -30, 30, 40);
            
            // Head
            ctx.fillStyle = '#ffdbac';
            ctx.beginPath();
            ctx.arc(0, -40, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Hair
            ctx.fillStyle = '#5e3a1f';
            ctx.fillRect(-15, -50, 30, 10);
            
            ctx.restore();
        }
        
        // Cutscene 2: Robot Awakens
        async function cutscene2() {
            console.log('Starting cutscene2');
            const pos = { 
                x: CANVAS_WIDTH / 2, 
                y: CANVAS_HEIGHT / 2,
                baseX: CANVAS_WIDTH / 2,
                baseY: CANVAS_HEIGHT / 2,
                time: 0
            };
            
            const startTime = Date.now();
            const duration = 6000; // 6 seconds
            
            // Fade in
            await fadeIn(600);
            
            // Main cutscene loop
            function renderFrame() {
                if (state !== 'cutscene2') return; // Stop if state changed
                
                // Clear
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Update time-based effects
                pos.time += 0.05;
                pos.x = pos.baseX + Math.sin(pos.time * 2) * 3;
                pos.y = pos.baseY + Math.sin(pos.time * 1.5) * 2;
                
                // Draw ambient light
                const lightRadius = 200;
                const gradient = ctx.createRadialGradient(
                    pos.x, pos.y, 0,
                    pos.x, pos.y, lightRadius
                );
                gradient.addColorStop(0, 'rgba(0, 100, 200, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Draw robot with animation
                ctx.save();
                ctx.translate(pos.x, pos.y);
                
                // Draw robot (simplified for now)
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-10, -5, 5, 0, Math.PI * 2);
                ctx.arc(10, -5, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Mouth (animated)
                const mouthHeight = 3 + Math.sin(pos.time * 5) * 2;
                ctx.fillStyle = '#fff';
                ctx.fillRect(-10, 15, 20, mouthHeight);
                
                ctx.restore();
                
                // Draw speech bubble
                drawSpeechBubble(
                    "Where... am I?",
                    CANVAS_WIDTH / 2 - 100, 50, 200, 60, 10
                );
                
                // Continue the animation if we're still in cutscene2 and time remains
                if (Date.now() - startTime < duration) {
                    requestAnimationFrame(renderFrame);
                } else {
                    // End of cutscene
                    state = 'tutorial';
                }
            }
            
            // Start the animation
            requestAnimationFrame(renderFrame);
            
            // Wait for the cutscene to complete
            await new Promise(resolve => {
                const checkComplete = () => {
                    if (state !== 'cutscene2') {
                        resolve();
                    } else {
                        setTimeout(checkComplete, 100);
                    }
                };
                checkComplete();
            });
        }
        
        // Tutorial
        async function showTutorial() {
            const startTime = Date.now();
            const messages = [
                { text: "Click to emit sound (your echo).", duration: 4000 },
                { text: "Use W A S D or arrow keys to move.", duration: 4000 },
                { text: "Find your way to the exit...", duration: 4000 }
            ];
            
            // Fade in
            await fadeIn(400);
            
            // Show each message
            for (const msg of messages) {
                const messageStart = Date.now();
                while (Date.now() - messageStart < msg.duration) {
                    // Clear
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    
                    // Draw message
                    ctx.fillStyle = 'white';
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(msg.text, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                    
                    await new Promise(r => requestAnimationFrame(r));
                }
            }
            
            // Fade out and start game
            await fadeOut(400);
            state = 'game';
        }
        
        // Fade effects
        async function fadeIn(duration) {
            const start = Date.now();
            const fade = document.createElement('div');
            fade.style.position = 'fixed';
            fade.style.top = '0';
            fade.style.left = '0';
            fade.style.width = '100%';
            fade.style.height = '100%';
            fade.style.background = 'black';
            fade.style.zIndex = '1000';
            fade.style.transition = `opacity ${duration}ms ease-out`;
            fade.style.opacity = '1';
            document.body.appendChild(fade);
            
            // Trigger reflow
            fade.offsetHeight;
            
            // Fade in
            fade.style.opacity = '0';
            
            // Wait for fade to complete
            await new Promise(r => setTimeout(r, duration + 50));
            document.body.removeChild(fade);
        }
        
        async function fadeOut(duration) {
            const fade = document.createElement('div');
            fade.style.position = 'fixed';
            fade.style.top = '0';
            fade.style.left = '0';
            fade.style.width = '100%';
            fade.style.height = '100%';
            fade.style.background = 'black';
            fade.style.zIndex = '1000';
            fade.style.transition = `opacity ${duration}ms ease-out`;
            fade.style.opacity = '0';
            document.body.appendChild(fade);
            
            // Trigger reflow
            fade.offsetHeight;
            
            // Fade out
            fade.style.opacity = '1';
            
            // Wait for fade to complete
            await new Promise(r => setTimeout(r, duration + 50));
            document.body.removeChild(fade);
        }
        
        // Game loop
        async function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update game state
            if (state === 'cutscene1') {
                await cutscene1();
            } else if (state === 'cutscene2') {
                await cutscene2();
            } else if (state === 'tutorial') {
                await showTutorial();
            } else if (state === 'game') {
                movePlayer();
                updateEchoes();
                
                // Draw everything
                drawEchoes();
                drawTutorialOverlay();
                drawHud();
                drawStoryOverlay();
                drawStatusMessage();
                
                // Draw UI elements on top
                const messageEl = document.getElementById('message');
                if (messageEl.textContent) {
                    ctx.fillStyle = 'white';
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(messageEl.textContent, CANVAS_WIDTH / 2, 50);
                }
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Handle window resize
        function handleResize() {
            // Keep the game canvas at a fixed size based on the maze
            const container = canvas.parentElement;
            const scale = Math.min(
                (window.innerWidth * 0.95) / CANVAS_WIDTH,
                (window.innerHeight * 0.9) / CANVAS_HEIGHT
            );
            
            canvas.style.width = `${CANVAS_WIDTH * scale}px`;
            canvas.style.height = `${CANVAS_HEIGHT * scale}px`;
            canvas.style.imageRendering = 'pixelated';
        }
        
        window.addEventListener('resize', handleResize);
        handleResize();

        // Prevent context menu on right-click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
        });

        // Start the game
        setupLevel();
        gameLoop();
        
        // Show welcome message
        showMessage('Click or tap to emit echo. Find the green exit!', 3000);
    </script>
</body>
</html>

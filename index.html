<!DOCTYPE html>
<html>
<head>
    <title>Echo - A Web Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }
        #gameCanvas {
            background-color: #000;
            touch-action: none;
        }
        #ui {
            margin-top: 10px;
            text-align: center;
            position: absolute;
            bottom: 20px;
            width: 100%;
            pointer-events: none;
        }
        #message {
            margin-top: 10px;
            color: #ff3333;
            height: 24px;
            font-size: 24px;
            text-shadow: 0 0 5px #000;
        }
        #cooldown-bar {
            width: 300px;
            height: 15px;
            background-color: #333;
            margin: 10px auto;
            border: 2px solid white;
            position: relative;
            display: none;
        }
        #cooldown-fill {
            height: 100%;
            width: 0%;
            background-color: #0099ff;
            transition: width 0.1s linear;
        }
        #cooldown-text {
            position: absolute;
            top: -25px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-size: 18px;
        }
        #level-display {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
            color: white;
            text-shadow: 0 0 5px #000;
        }
        .fullscreen-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            max-width: 80%;
        }
        .fullscreen-message h1 {
            color: #00ff00;
            font-size: 48px;
            margin: 0 0 20px 0;
        }
        .fullscreen-message p {
            font-size: 24px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="level-display">Level: <span id="level">1</span></div>
    <div id="ui">
        <div id="cooldown-bar">
            <div id="cooldown-fill"></div>
            <div id="cooldown-text">Echo Cooldown</div>
        </div>
        <div id="message"></div>
    </div>

    <script>
        // Game constants
        const CELL_SIZE = 40;
        const MAZE_WIDTH = 31;
        const MAZE_HEIGHT = 21;
        const CANVAS_WIDTH = MAZE_WIDTH * CELL_SIZE;
        const CANVAS_HEIGHT = MAZE_HEIGHT * CELL_SIZE;

        // Colors
        const COLORS = {
            BLACK: '#000000',
            WHITE: '#FFFFFF',
            WALL: '#000050',
            EXIT: '#00FF00',
            PLAYER: '#0066FF',
            ECHO: 'rgba(0, 200, 255, 0.7)',
            DARKNESS: 'rgba(0, 0, 0, 0.9)'
        };

        // Game assets
        let playerImage = new Image();
        playerImage.src = 'https://hc-cdn.hel1.your-objectstorage.com/s/v3/596845749eb07a7f4f90d02f10aa664dd5102874_player.png';
        
        const TUTORIAL_LINES = [
            'Tutorial Level!',
            'Move with W A S D or the Arrow Keys.',
            'Hold Shift to sprint when you need speed.',
            'Click or tap to blast your echo.',
            'Reach the green exit to move on.'
        ];
        let tutorialLevelActive = false;
        let tutorialLines = [];

        // Game state
        let state = 'cutscene1'; // Start with first cutscene
        let level = 1;
        let lastEchoTime = 0;
        let echoCooldown = 2000; // Start with 2 second cooldown
        let cooldownMessage = '';
        let cooldownTimer = 0;
        let gameComplete = false;

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Game objects
        const player = {
            x: CELL_SIZE / 2,
            y: CELL_SIZE / 2,
            hitRadius: 12,
            drawRadius: 18,
            speed: 2
        };

        let maze = [];
        let walls = [];
        let exit = { x: 0, y: 0 };
        let echoes = [];
        let levelComplete = false;

        // Generate maze using recursive backtracking (same as Pygame version)
        function generateMaze(width, height) {
            const maze = Array(height).fill().map(() => Array(width).fill(1));
            const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]];
            
            function carve(x, y) {
                maze[y][x] = 0;
                
                // Shuffle directions
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }
                
                for (const [dx, dy] of directions) {
                    const nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && maze[ny][nx] === 1) {
                        maze[y + dy/2][x + dx/2] = 0;
                        carve(nx, ny);
                    }
                }
            }
            
            carve(0, 0);
            maze[0][0] = 0;
            maze[height - 1][width - 1] = 0;
            return maze;
        }

        function setupLevel() {
            tutorialLevelActive = (level === 1);
            tutorialLines = tutorialLevelActive ? [...TUTORIAL_LINES] : [];
            
            // Generate new maze
            maze = generateMaze(MAZE_WIDTH, MAZE_HEIGHT);
            
            // Reset player position
            player.x = CELL_SIZE / 2;
            player.y = CELL_SIZE / 2;
            
            // Set exit position
            exit.x = (MAZE_WIDTH - 1) * CELL_SIZE + CELL_SIZE/2;
            exit.y = (MAZE_HEIGHT - 1) * CELL_SIZE + CELL_SIZE/2;
            
            // Reset walls array
            walls = [];
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 1) {
                        walls.push({
                            x: x * CELL_SIZE,
                            y: y * CELL_SIZE,
                            width: CELL_SIZE,
                            height: CELL_SIZE
                        });
                    }
                }
            }
            
            // Clear echoes and reset level state
            echoes = [];
            levelComplete = false;
            
            // Update level display
            document.getElementById('level').textContent = tutorialLevelActive ? 'Tutorial' : level;
        }

        // Check collision between two rectangles
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // Handle player movement
        const keys = new Set();
        const keyMap = {
            'arrowup': 'up',
            'w': 'up',
            'arrowdown': 'down',
            's': 'down',
            'arrowleft': 'left',
            'a': 'left',
            'arrowright': 'right',
            'd': 'right',
            'shift': 'sprint'
        };

        // Track active movement directions
        const activeDirections = {
            up: false,
            down: false,
            left: false,
            right: false,
            sprint: false
        };

        // Handle keydown
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys.add(key);
            
            // Update active directions
            const direction = keyMap[key];
            if (direction) {
                activeDirections[direction] = true;
            }
            
            // Prevent default for movement and space keys
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'w', 'a', 's', 'd', 'shift'].includes(key)) {
                e.preventDefault();
            }
        });
        
        // Handle keyup
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            keys.delete(key);
            
            // Update active directions
            const direction = keyMap[key];
            if (direction) {
                activeDirections[direction] = false;
            }
        });
        
        // Handle window blur (reset all keys when window loses focus)
        window.addEventListener('blur', () => {
            keys.clear();
            Object.keys(activeDirections).forEach(key => {
                activeDirections[key] = false;
            });
        });

        function movePlayer() {
            if (levelComplete) return;
            
            const prevX = player.x;
            const prevY = player.y;
            
            // Calculate movement vector
            let moveX = 0;
            let moveY = 0;
            
            // Base speed (normal walking speed)
            const baseSpeed = 2;
            const sprintMultiplier = 2; // Double speed when sprinting
            
            // Calculate movement based on active directions
            if (activeDirections.up) moveY -= 1;
            if (activeDirections.down) moveY += 1;
            if (activeDirections.left) moveX -= 1;
            if (activeDirections.right) moveX += 1;
            
            // Normalize diagonal movement (so moving diagonally isn't faster)
            if (moveX !== 0 && moveY !== 0) {
                const invSqrt2 = 0.7071; // 1/sqrt(2)
                moveX *= invSqrt2;
                moveY *= invSqrt2;
            }
            
            // Apply sprint if shift is held
            const speedMultiplier = activeDirections.sprint ? sprintMultiplier : 1;
            const speed = baseSpeed * speedMultiplier;
            
            // Update player position
            player.x += moveX * speed;
            player.y += moveY * speed;
            
            // Create player rectangle for collision detection
            const playerRect = {
                x: player.x - player.hitRadius,
                y: player.y - player.hitRadius,
                width: player.hitRadius * 2,
                height: player.hitRadius * 2
            };
            
            // Wall collision
            for (const wall of walls) {
                if (checkCollision(playerRect, wall)) {
                    player.x = prevX;
                    player.y = prevY;
                    break;
                }
            }
            
            // Keep player in bounds
            player.x = Math.max(player.hitRadius, Math.min(player.x, CANVAS_WIDTH - player.hitRadius));
            player.y = Math.max(player.hitRadius, Math.min(player.y, CANVAS_HEIGHT - player.hitRadius));
            
            // Check if reached exit
            const distToExit = Math.hypot(player.x - exit.x, player.y - exit.y);
            if (distToExit < CELL_SIZE && !levelComplete) {
                levelComplete = true;
                level++;
                echoCooldown = Math.max(500, 2000 - level * 100); // Decrease cooldown with level
                
                // Show level complete message
                showMessage('Level Complete!', 1500, () => {
                    setupLevel();
                });
            }
        }

        // Show a temporary message
        function showMessage(message, duration = 1000, callback = null) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = message;
            messageEl.style.display = 'block';
            
            setTimeout(() => {
                messageEl.textContent = '';
                messageEl.style.display = 'none';
                if (callback) callback();
            }, duration);
        }

        // Handle mouse/touch for echoes
        function handleEcho() {
            const currentTime = Date.now();
            if (currentTime - lastEchoTime >= echoCooldown) {
                echoes.push({
                    x: player.x,
                    y: player.y,
                    radius: 5,
                    maxRadius: 300,
                    alpha: 1,
                    speed: 8
                });
                
                lastEchoTime = currentTime;
                
                // Show cooldown UI
                const cooldownBar = document.getElementById('cooldown-bar');
                const cooldownFill = document.getElementById('cooldown-fill');
                
                cooldownBar.style.display = 'block';
                cooldownFill.style.transition = `width ${echoCooldown}ms linear`;
                
                // Trigger the animation
                setTimeout(() => {
                    cooldownFill.style.width = '100%';
                }, 10);
                
                setTimeout(() => {
                    cooldownBar.style.display = 'none';
                    cooldownFill.style.width = '0%';
                }, echoCooldown);
                
                // Play echo sound (you'll need to add a sound file for this to work)
                // playSound('echo.mp3');
            } else {
                cooldownMessage = 'Echo On Cooldown';
                showMessage(cooldownMessage, 1000);
            }
        }
        
        // Set up event listeners for echo
        canvas.addEventListener('click', handleEcho);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleEcho();
        });

        // Update echoes
        function updateEchoes() {
            for (let i = echoes.length - 1; i >= 0; i--) {
                const echo = echoes[i];
                echo.radius += echo.speed;
                echo.alpha = 1 - (echo.radius / echo.maxRadius);
                
                if (echo.alpha <= 0) {
                    echoes.splice(i, 1);
                }
            }
        }

        // Draw functions
        function drawMaze() {
            // Draw walls
            ctx.fillStyle = COLORS.WALL;
            for (const wall of walls) {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            }
            
            // Draw exit
            ctx.fillStyle = COLORS.EXIT;
            ctx.fillRect(
                (MAZE_WIDTH - 1) * CELL_SIZE, 
                (MAZE_HEIGHT - 1) * CELL_SIZE, 
                CELL_SIZE, 
                CELL_SIZE
            );
        }

        function drawPlayer() {
            // Draw player sprite
            if (playerImage.complete) {
                ctx.save();
                ctx.translate(player.x, player.y);
                // Scale down the image (assuming original is larger than we want)
                ctx.drawImage(playerImage, -player.drawRadius, -player.drawRadius, player.drawRadius * 2, player.drawRadius * 2);
                ctx.restore();
            } else {
                // Fallback circle if image isn't loaded
                ctx.fillStyle = COLORS.PLAYER;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.drawRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawTutorialOverlay() {
            if (!tutorialLevelActive || tutorialLines.length === 0) {
                return;
            }
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            const panelHeight = 160;
            ctx.fillRect(0, 50, CANVAS_WIDTH, panelHeight);
            ctx.fillStyle = COLORS.WHITE;
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            tutorialLines.forEach((line, index) => {
                ctx.fillText(line, CANVAS_WIDTH / 2, 85 + index * 28);
            });
            ctx.restore();
        }

        function drawEchoes() {
            // Draw complete darkness first
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Create a clipping region for visible areas
            ctx.save();
            ctx.beginPath();
            
            // Add a small area around the player that's always visible
            const baseGlow = Math.max(player.drawRadius, player.hitRadius + 4);
            ctx.arc(player.x, player.y, baseGlow, 0, Math.PI * 2);
            
            // Add echo circles as visible areas if they exist
            for (const echo of echoes) {
                ctx.moveTo(echo.x + echo.radius, echo.y);
                ctx.arc(echo.x, echo.y, echo.radius, 0, Math.PI * 2);
                
                // Draw echo ring
                ctx.strokeStyle = `rgba(0, 200, 255, ${echo.alpha * 0.7})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Use the path to create a clipping region
            ctx.clip();
            
            // Draw the maze in the visible areas
            drawMaze();
            
            // Draw the player on top of the maze but within the visible area
            drawPlayer();
            
            // Restore the context
            ctx.restore();
        }

        // Cutscene 1: Conveyor Belt
        async function cutscene1() {
            const robots = [];
            const beltSpeed = 2;
            const beltY = 400;
            
            // Create robots on a conveyor belt with slight vertical variation
            for (let i = 0; i < 6; i++) {
                robots.push({
                    x: 800 + i * 120,
                    y: beltY + (Math.random() * 20 - 10), // Slight vertical variation
                    width: 40,
                    height: 40,
                    frame: Math.floor(Math.random() * 4), // For animation
                    time: Math.random() * 1000 // For animation timing
                });
            }
            
            const startTime = Date.now();
            const duration = 6000; // 6 seconds
            
            // Fade in
            await fadeIn(800);
            
            // Main cutscene loop
            while (Date.now() - startTime < duration) {
                // Clear
                ctx.fillStyle = '#0A0A0A';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Draw conveyor belt
                ctx.fillStyle = '#505050';
                ctx.fillRect(0, beltY - 10, CANVAS_WIDTH, 60);
                
                // Draw belt lights
                ctx.fillStyle = '#1E1E1E';
                for (let i = 0; i < CANVAS_WIDTH; i += 60) {
                    const offset = (Date.now() / 100) % 60;
                    ctx.beginPath();
                    ctx.arc((i + offset) % CANVAS_WIDTH, beltY + 20, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Update and draw robots with animation
                for (const robot of robots) {
                    robot.x -= beltSpeed;
                    if (robot.x < -robot.width) robot.x = CANVAS_WIDTH;
                    
                    // Update animation frame
                    robot.time += 1000 / 60; // Assuming 60fps
                    robot.frame = Math.floor(robot.time / 200) % 4; // Change frame every 200ms
                    
                    // Save context for rotation
                    ctx.save();
                    
                    // Move to robot position and apply slight rotation based on position
                    const rotation = Math.sin(robot.time * 0.005) * 0.1; // Gentle rocking
                    ctx.translate(robot.x + robot.width/2, robot.y + robot.height/2);
                    ctx.rotate(rotation);
                    
                    if (playerImage.complete) {
                        // Draw robot with current frame
                        const frameSize = 64; // Assuming sprite sheet with 64x64 frames
                        const frameX = (robot.frame % 2) * frameSize;
                        const frameY = Math.floor(robot.frame / 2) * frameSize;
                        
                        // Draw shadow
                        ctx.save();
                        ctx.scale(1, 0.3);
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.beginPath();
                        ctx.ellipse(0, 20, robot.width/2, 5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                        
                        // Draw robot
                        ctx.drawImage(
                            playerImage,
                            frameX, frameY, frameSize, frameSize,
                            -robot.width/2, -robot.height/2, robot.width, robot.height
                        );
                    } else {
                        // Fallback if image isn't loaded
                        ctx.fillStyle = COLORS.PLAYER;
                        ctx.fillRect(-robot.width/2, -robot.height/2, robot.width, robot.height);
                    }
                    
                    ctx.restore();
                }
                
                // Draw dialogue with speech bubbles
                const elapsed = Date.now() - startTime;
                
                // Worker 1's speech
                if (elapsed < 3000) {
                    drawSpeechBubble(
                        "Worker 1: We ran out of cameras!",
                        200, 80, 300, 60, 20
                    );
                } 
                // Worker 2's speech
                else {
                    drawSpeechBubble(
                        "Worker 2: Just give him an extra speaker!",
                        180, 130, 400, 60, 20
                    );
                }
                
                // Draw worker sprites (simplified)
                drawWorker(100, 100, 0);
                drawWorker(100, 180, 1);
                
                await new Promise(r => requestAnimationFrame(r));
            }
            
            // Fade out and move to next state
            await fadeOut(600);
            state = 'cutscene2';
        }
        
        // Helper function to draw speech bubbles
        function drawSpeechBubble(text, x, y, width, height, radius) {
            // Bubble tail
            const tailSize = 10;
            
            // Draw bubble
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // Rounded rectangle
            roundRect(ctx, x, y, width, height, radius, true, true);
            
            // Tail
            ctx.beginPath();
            ctx.moveTo(x + 40, y + height);
            ctx.lineTo(x + 20, y + height + tailSize);
            ctx.lineTo(x + 60, y + height);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Text
            ctx.fillStyle = '#000';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            wrapText(ctx, text, x + 20, y + 30, width - 40, 20);
        }
        
        // Helper to draw rounded rectangles
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) ctx.fill();
            if (stroke) ctx.stroke();
        }
        
        // Helper to wrap text
        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let testLine = '';
            let lineCount = 0;
            
            for (let n = 0; n < words.length; n++) {
                testLine = line + words[n] + ' ';
                const metrics = context.measureText(testLine);
                const testWidth = metrics.width;
                
                if (testWidth > maxWidth && n > 0) {
                    context.fillText(line, x, y);
                    line = words[n] + ' ';
                    y += lineHeight;
                    lineCount++;
                } else {
                    line = testLine;
                }
            }
            
            context.fillText(line, x, y);
        }
        
        // Draw worker sprite (simplified)
        function drawWorker(x, y, type) {
            ctx.save();
            ctx.translate(x, y);
            
            // Body
            ctx.fillStyle = type === 0 ? '#4a86e8' : '#e69138';
            ctx.fillRect(-15, -30, 30, 40);
            
            // Head
            ctx.fillStyle = '#ffdbac';
            ctx.beginPath();
            ctx.arc(0, -40, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Hair
            ctx.fillStyle = '#5e3a1f';
            ctx.fillRect(-15, -50, 30, 10);
            
            ctx.restore();
        }
        
        // Cutscene 2: Robot Awakens
        async function cutscene2() {
            console.log('Starting cutscene2');
            const pos = { 
                x: CANVAS_WIDTH / 2, 
                y: CANVAS_HEIGHT / 2,
                baseX: CANVAS_WIDTH / 2,
                baseY: CANVAS_HEIGHT / 2,
                time: 0
            };
            
            const startTime = Date.now();
            const duration = 6000; // 6 seconds
            
            // Fade in
            await fadeIn(600);
            
            // Main cutscene loop
            function renderFrame() {
                if (state !== 'cutscene2') return; // Stop if state changed
                
                // Clear
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Update time-based effects
                pos.time += 0.05;
                pos.x = pos.baseX + Math.sin(pos.time * 2) * 3;
                pos.y = pos.baseY + Math.sin(pos.time * 1.5) * 2;
                
                // Draw ambient light
                const lightRadius = 200;
                const gradient = ctx.createRadialGradient(
                    pos.x, pos.y, 0,
                    pos.x, pos.y, lightRadius
                );
                gradient.addColorStop(0, 'rgba(0, 100, 200, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Draw robot with animation
                ctx.save();
                ctx.translate(pos.x, pos.y);
                
                // Draw robot (simplified for now)
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-10, -5, 5, 0, Math.PI * 2);
                ctx.arc(10, -5, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Mouth (animated)
                const mouthHeight = 3 + Math.sin(pos.time * 5) * 2;
                ctx.fillStyle = '#fff';
                ctx.fillRect(-10, 15, 20, mouthHeight);
                
                ctx.restore();
                
                // Draw speech bubble
                drawSpeechBubble(
                    "Where... am I?",
                    CANVAS_WIDTH / 2 - 100, 50, 200, 60, 10
                );
                
                // Continue the animation if we're still in cutscene2 and time remains
                if (Date.now() - startTime < duration) {
                    requestAnimationFrame(renderFrame);
                } else {
                    // End of cutscene
                    state = 'tutorial';
                }
            }
            
            // Start the animation
            requestAnimationFrame(renderFrame);
            
            // Wait for the cutscene to complete
            await new Promise(resolve => {
                const checkComplete = () => {
                    if (state !== 'cutscene2') {
                        resolve();
                    } else {
                        setTimeout(checkComplete, 100);
                    }
                };
                checkComplete();
            });
        }
        
        // Tutorial
        async function showTutorial() {
            const startTime = Date.now();
            const messages = [
                { text: "Click to emit sound (your echo).", duration: 4000 },
                { text: "Use W A S D or arrow keys to move.", duration: 4000 },
                { text: "Find your way to the exit...", duration: 4000 }
            ];
            
            // Fade in
            await fadeIn(400);
            
            // Show each message
            for (const msg of messages) {
                const messageStart = Date.now();
                while (Date.now() - messageStart < msg.duration) {
                    // Clear
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    
                    // Draw message
                    ctx.fillStyle = 'white';
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(msg.text, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                    
                    await new Promise(r => requestAnimationFrame(r));
                }
            }
            
            // Fade out and start game
            await fadeOut(400);
            state = 'game';
        }
        
        // Fade effects
        async function fadeIn(duration) {
            const start = Date.now();
            const fade = document.createElement('div');
            fade.style.position = 'fixed';
            fade.style.top = '0';
            fade.style.left = '0';
            fade.style.width = '100%';
            fade.style.height = '100%';
            fade.style.background = 'black';
            fade.style.zIndex = '1000';
            fade.style.transition = `opacity ${duration}ms ease-out`;
            fade.style.opacity = '1';
            document.body.appendChild(fade);
            
            // Trigger reflow
            fade.offsetHeight;
            
            // Fade in
            fade.style.opacity = '0';
            
            // Wait for fade to complete
            await new Promise(r => setTimeout(r, duration + 50));
            document.body.removeChild(fade);
        }
        
        async function fadeOut(duration) {
            const fade = document.createElement('div');
            fade.style.position = 'fixed';
            fade.style.top = '0';
            fade.style.left = '0';
            fade.style.width = '100%';
            fade.style.height = '100%';
            fade.style.background = 'black';
            fade.style.zIndex = '1000';
            fade.style.transition = `opacity ${duration}ms ease-out`;
            fade.style.opacity = '0';
            document.body.appendChild(fade);
            
            // Trigger reflow
            fade.offsetHeight;
            
            // Fade out
            fade.style.opacity = '1';
            
            // Wait for fade to complete
            await new Promise(r => setTimeout(r, duration + 50));
            document.body.removeChild(fade);
        }
        
        // Game loop
        async function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update game state
            if (state === 'cutscene1') {
                await cutscene1();
            } else if (state === 'cutscene2') {
                await cutscene2();
            } else if (state === 'tutorial') {
                await showTutorial();
            } else if (state === 'game') {
                movePlayer();
                updateEchoes();
                
                // Draw everything
                drawEchoes();
                drawTutorialOverlay();
                
                // Draw UI elements on top
                const messageEl = document.getElementById('message');
                if (messageEl.textContent) {
                    ctx.fillStyle = 'white';
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(messageEl.textContent, CANVAS_WIDTH / 2, 50);
                }
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Handle window resize
        function handleResize() {
            // Keep the game canvas at a fixed size based on the maze
            const container = canvas.parentElement;
            const scale = Math.min(
                (window.innerWidth * 0.95) / CANVAS_WIDTH,
                (window.innerHeight * 0.9) / CANVAS_HEIGHT
            );
            
            canvas.style.width = `${CANVAS_WIDTH * scale}px`;
            canvas.style.height = `${CANVAS_HEIGHT * scale}px`;
            canvas.style.imageRendering = 'pixelated';
        }
        
        window.addEventListener('resize', handleResize);
        handleResize();

        // Prevent context menu on right-click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
        });

        // Start the game
        setupLevel();
        gameLoop();
        
        // Show welcome message
        showMessage('Click or tap to emit echo. Find the green exit!', 3000);
    </script>
</body>
</html>
